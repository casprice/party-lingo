"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EphemeralDataStore = void 0;
const uuid_1 = require("uuid");
const utils_1 = require("../utils");
const listeners_1 = __importDefault(require("../listeners"));
const types_1 = require("../types");
let data = [];
const testForExistingGameCode = (gameCode) => __awaiter(void 0, void 0, void 0, function* () { return Boolean(data.find((game) => game.gameCode === gameCode)); });
class EphemeralDataStore extends listeners_1.default {
    constructor() {
        super(...arguments);
        this.listeners = Object.keys(types_1.DataStoreEvents).reduce((acc, curr) => {
            return Object.assign({ [curr]: [] }, acc);
        }, {});
    }
    setup() {
        return __awaiter(this, void 0, void 0, function* () {
            data = [];
            return;
        });
    }
    createGame(gameCode) {
        return __awaiter(this, void 0, void 0, function* () {
            const game = {
                gameId: uuid_1.v4(),
                gameCode: gameCode && !(yield testForExistingGameCode(gameCode))
                    ? gameCode
                    : yield utils_1.createUniqueGameCode(testForExistingGameCode),
                started: false,
                players: [],
                spectators: [],
                turns: [],
                custom: {}
            };
            data.push(game);
            yield this.runEventListeners(types_1.DataStoreEvents.createGame, game, this);
            return game;
        });
    }
    findGame(gameId) {
        return __awaiter(this, void 0, void 0, function* () {
            return data.find((game) => game.gameId === gameId);
        });
    }
    findGameWithCode(gameCode) {
        return __awaiter(this, void 0, void 0, function* () {
            return data.find((game) => game.gameCode === gameCode);
        });
    }
    editGame(gameId, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            const game = yield this.findGame(gameId);
            if (!game) {
                throw new Error(`Game not found with id ${gameId}`);
            }
            if (typeof callback === 'function') {
                return yield callback(game);
            }
            return game;
        });
    }
    leaveGame(gameId, playerId) {
        return __awaiter(this, void 0, void 0, function* () {
            const game = yield this.findGame(gameId);
            if (!game) {
                throw new Error(`Game not found with id ${gameId}`);
            }
            utils_1.removeArrayItemWithFilter(game.players, (player) => player.playerId === playerId);
            utils_1.removeArrayItemWithFilter(game.spectators, (spectator) => spectator.spectatorId === playerId);
            yield this.runEventListeners(types_1.DataStoreEvents.leaveGame, game, this);
            return;
        });
    }
    startGame(gameId) {
        return __awaiter(this, void 0, void 0, function* () {
            const game = yield this.findGame(gameId);
            if (!game) {
                throw new Error(`Game not found with id ${gameId}`);
            }
            game.started = true;
            game.turns.push(yield this.createTurn(gameId));
            yield this.runEventListeners(types_1.DataStoreEvents.startGame, game, this);
            return game;
        });
    }
    endGame(gameId) {
        return __awaiter(this, void 0, void 0, function* () {
            utils_1.removeArrayItemWithFilter(data, (game) => game.gameId === gameId);
            return;
        });
    }
    createPlayer(gameId, name, avatar) {
        return __awaiter(this, void 0, void 0, function* () {
            const game = yield this.findGame(gameId);
            if (!game) {
                throw new Error(`Game not found with id ${gameId}`);
            }
            const player = {
                playerId: uuid_1.v4(),
                gameId,
                name,
                avatar,
                isAdmin: game.players.length === 0,
                custom: {}
            };
            game.players.push(player);
            yield this.runEventListeners(types_1.DataStoreEvents.createPlayer, player, this);
            return player;
        });
    }
    findPlayer(gameId, playerId) {
        return __awaiter(this, void 0, void 0, function* () {
            const game = yield this.findGame(gameId);
            if (!game) {
                throw new Error(`Game not found with id ${gameId}`);
            }
            return game.players.find((player) => player.playerId === playerId);
        });
    }
    editPlayer(gameId, playerId, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            const player = yield this.findPlayer(gameId, playerId);
            if (!player) {
                throw new Error(`Player not found with id ${playerId}`);
            }
            if (typeof callback === 'function') {
                return yield callback(player);
            }
            return player;
        });
    }
    createSpectator(gameId) {
        return __awaiter(this, void 0, void 0, function* () {
            const game = yield this.findGame(gameId);
            if (!game) {
                throw new Error(`Game not found with id ${gameId}`);
            }
            const spectator = {
                spectatorId: uuid_1.v4(),
                gameId,
                name: '',
                custom: {}
            };
            game.spectators.push(spectator);
            yield this.runEventListeners(types_1.DataStoreEvents.createSpectator, spectator, this);
            return spectator;
        });
    }
    findSpectator(gameId, spectatorId) {
        return __awaiter(this, void 0, void 0, function* () {
            const game = yield this.findGame(gameId);
            if (!game) {
                throw new Error(`Game not found with id ${gameId}`);
            }
            return game.spectators.find((spectator) => spectator.spectatorId === spectatorId);
        });
    }
    editSpectator(gameId, spectatorId, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            const spectator = yield this.findSpectator(gameId, spectatorId);
            if (!spectator) {
                throw new Error(`Spectator not found with id ${spectatorId}`);
            }
            if (typeof callback === 'function') {
                return yield callback(spectator);
            }
            return spectator;
        });
    }
    createTurn(gameId) {
        return __awaiter(this, void 0, void 0, function* () {
            const game = yield this.findGame(gameId);
            if (!game) {
                throw new Error(`Game not found with id ${gameId}`);
            }
            const turn = {
                turnId: uuid_1.v4(),
                gameId,
                index: game.turns.length + 1,
                custom: {}
            };
            yield this.runEventListeners(types_1.DataStoreEvents.createTurn, turn, this);
            return turn;
        });
    }
    findTurn(gameId, turnId) {
        return __awaiter(this, void 0, void 0, function* () {
            const game = yield this.findGame(gameId);
            if (!game) {
                throw new Error(`Game not found with id ${gameId}`);
            }
            const turn = game.turns.find((turn) => turn.turnId === turnId);
            if (!turn) {
                throw new Error(`Turn with id ${turnId} not found!`);
            }
            return turn;
        });
    }
    currentTurn(gameId) {
        return __awaiter(this, void 0, void 0, function* () {
            const game = yield this.findGame(gameId);
            if (!game) {
                throw new Error(`Game not found with id ${gameId}`);
            }
            if (game.turns.length > 0) {
                return game.turns[game.turns.length - 1];
            }
            return;
        });
    }
    editTurn(gameId, turnId, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            const turn = yield this.findTurn(gameId, turnId);
            if (!turn) {
                throw new Error(`Turn not found with id ${turnId}`);
            }
            if (typeof callback === 'function') {
                return yield callback(turn);
            }
            return turn;
        });
    }
    editCurrentTurn(gameId, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            const turn = yield this.currentTurn(gameId);
            if (!turn) {
                throw new Error(`Current turn not found for game with id ${gameId}`);
            }
            return yield this.editTurn(gameId, turn.turnId, callback);
        });
    }
    endCurrentTurn(gameId) {
        return __awaiter(this, void 0, void 0, function* () {
            const game = yield this.findGame(gameId);
            if (!game) {
                throw new Error(`Game not found with id ${gameId}`);
            }
            yield this.editCurrentTurn(gameId, (turn) => __awaiter(this, void 0, void 0, function* () {
                yield this.runEventListeners(types_1.DataStoreEvents.endCurrentTurn, turn, this);
                return turn;
            }));
            if (game && game.turns) {
                const turn = yield this.createTurn(gameId);
                turn.index = game.turns.length + 1;
                game.turns.push(turn);
            }
            return;
        });
    }
}
exports.EphemeralDataStore = EphemeralDataStore;
