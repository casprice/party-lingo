"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PostgresDataStore = exports.client = void 0;
const pg_1 = require("pg");
const utils_1 = require("../utils");
const listeners_1 = __importDefault(require("../listeners"));
const types_1 = require("../types");
exports.client = new pg_1.Client({
    host: process.env.PGHOST || 'localhost',
    port: process.env.PGPORT || 5432,
    user: process.env.PGUSER || 'postgres',
    password: process.env.PGPASSWORD || '',
    database: process.env.PGDATABASE || 'travis_ci_test'
});
const formatValue = (value) => {
    if (!value)
        return null;
    else if (typeof value === 'object')
        value = JSON.stringify(value);
    return `'${String(value).replace(/'/g, '&#39;')}'`;
};
const testForExistingGameCode = (gameCode) => __awaiter(void 0, void 0, void 0, function* () {
    return Boolean((yield exports.client.query('SELECT COUNT("gameCode") FROM "game" WHERE "gameCode" = $1 LIMIT 1', [gameCode])).rows.find((row) => row).count > 0);
});
class PostgresDataStore extends listeners_1.default {
    constructor() {
        super(...arguments);
        this.listeners = Object.keys(types_1.DataStoreEvents).reduce((acc, curr) => {
            return Object.assign({ [curr]: [] }, acc);
        }, {});
    }
    setup() {
        return __awaiter(this, void 0, void 0, function* () {
            yield exports.client.connect();
            return;
        });
    }
    createGame(gameCode) {
        return __awaiter(this, void 0, void 0, function* () {
            const code = gameCode && !(yield testForExistingGameCode(gameCode))
                ? gameCode
                : yield utils_1.createUniqueGameCode(testForExistingGameCode);
            const game = (yield exports.client.query('SELECT * FROM createGame($1)', [code])).rows.find((row) => row);
            return yield this.editGame(game.gameId, (game) => __awaiter(this, void 0, void 0, function* () {
                yield this.runEventListeners(types_1.DataStoreEvents.createGame, game, this);
                return game;
            }));
        });
    }
    findGame(gameId) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield exports.client.query('SELECT * FROM findGame($1)', [gameId])).rows.find((row) => row);
        });
    }
    findGameWithCode(gameCode) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield exports.client.query('SELECT * FROM findGameWithCode($1)', [gameCode])).rows.find((row) => row);
        });
    }
    editGame(gameId, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            const game = yield this.findGame(gameId);
            if (!game) {
                throw new Error(`Game not found with id ${gameId}`);
            }
            if (typeof callback === 'function') {
                const edited = yield callback(game);
                yield exports.client.query(`UPDATE "game" SET ${Object.keys(edited)
                    .filter(key => ['custom'].indexOf(key) !== -1)
                    .map(key => `"${key}" = ${formatValue(edited[key])}`)
                    .join(', ')} WHERE "gameId" = $1`, [gameId]);
                return (yield exports.client.query(`SELECT * FROM findGame($1)`, [gameId])).rows.find((row) => row);
            }
            return game;
        });
    }
    leaveGame(gameId, playerId) {
        return __awaiter(this, void 0, void 0, function* () {
            const game = yield this.findGame(gameId);
            if (!game) {
                throw new Error(`Game not found with id ${gameId}`);
            }
            yield exports.client.query('DELETE FROM "player" WHERE "gameId" = $1 and "playerId" = $2', [gameId, playerId]);
            yield exports.client.query('DELETE FROM "spectator" WHERE "gameId" = $1 and "spectatorId" = $2', [gameId, playerId]);
            yield this.editGame(game.gameId, (game) => __awaiter(this, void 0, void 0, function* () {
                yield this.runEventListeners(types_1.DataStoreEvents.leaveGame, game, this);
                return game;
            }));
            return;
        });
    }
    startGame(gameId) {
        return __awaiter(this, void 0, void 0, function* () {
            const game = (yield exports.client.query(`SELECT * FROM startGame($1)`, [gameId])).rows.find((row) => row);
            if (!game) {
                throw new Error(`Game not found with id ${gameId}`);
            }
            yield this.createTurn(gameId);
            return yield this.editGame(game.gameId, (game) => __awaiter(this, void 0, void 0, function* () {
                yield this.runEventListeners(types_1.DataStoreEvents.startGame, game, this);
                return game;
            }));
        });
    }
    endGame(gameId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield exports.client.query('SELECT * FROM endGame($1)', [gameId]);
            return;
        });
    }
    createPlayer(gameId, name, avatar) {
        return __awaiter(this, void 0, void 0, function* () {
            const player = (yield exports.client.query('SELECT * FROM createPlayer($1, $2, $3)', [
                gameId,
                name,
                avatar
            ])).rows.find((row) => row);
            return yield this.editPlayer(gameId, player.playerId, (player) => __awaiter(this, void 0, void 0, function* () {
                yield this.runEventListeners(types_1.DataStoreEvents.createPlayer, player, this);
                return player;
            }));
        });
    }
    findPlayer(gameId, playerId) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield exports.client.query('SELECT * FROM findPlayer($1, $2)', [
                gameId,
                playerId
            ])).rows.find((row) => row);
        });
    }
    editPlayer(gameId, playerId, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            const player = yield this.findPlayer(gameId, playerId);
            if (!player) {
                throw new Error(`Player not found with id ${playerId}`);
            }
            if (typeof callback === 'function') {
                const edited = yield callback(player);
                return (yield exports.client.query(`UPDATE "player" SET ${Object.keys(edited)
                    .filter(key => ['name', 'avatar', 'custom'].indexOf(key) !== -1)
                    .map(key => `"${key}" = ${formatValue(edited[key])}`)
                    .join(', ')} WHERE "gameId" = $1 and "playerId" = $2 RETURNING "playerId", "gameId", "name", "avatar", "isAdmin", "custom"`, [gameId, playerId])).rows.find((row) => row);
            }
            return player;
        });
    }
    createSpectator(gameId) {
        return __awaiter(this, void 0, void 0, function* () {
            const spectator = (yield exports.client.query('SELECT * FROM createSpectator($1)', [gameId])).rows.find((row) => row);
            return yield this.editSpectator(gameId, spectator.spectatorId, (spectator) => __awaiter(this, void 0, void 0, function* () {
                yield this.runEventListeners(types_1.DataStoreEvents.createSpectator, spectator, this);
                return spectator;
            }));
        });
    }
    findSpectator(gameId, spectatorId) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield exports.client.query('SELECT * FROM findSpectator($1, $2)', [
                gameId,
                spectatorId
            ])).rows.find((row) => row);
        });
    }
    editSpectator(gameId, spectatorId, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            const spectator = yield this.findSpectator(gameId, spectatorId);
            if (!spectator) {
                throw new Error(`Spectator not found with id ${spectatorId}`);
            }
            if (typeof callback === 'function') {
                const edited = yield callback(spectator);
                return (yield exports.client.query(`UPDATE "spectator" SET ${Object.keys(edited)
                    .filter(key => ['name', 'custom'].indexOf(key) !== -1)
                    .map(key => `"${key}" = ${formatValue(edited[key])}`)
                    .join(', ')} WHERE "gameId" = $1 and "spectatorId" = $2 RETURNING "spectatorId", "gameId", "name", "custom"`, [gameId, spectatorId])).rows.find((row) => row);
            }
            return spectator;
        });
    }
    createTurn(gameId) {
        return __awaiter(this, void 0, void 0, function* () {
            const turn = (yield exports.client.query('SELECT * FROM createTurn($1)', [gameId])).rows.find((row) => row);
            return yield this.editTurn(gameId, turn.turnId, (turn) => __awaiter(this, void 0, void 0, function* () {
                yield this.runEventListeners(types_1.DataStoreEvents.createTurn, turn, this);
                return turn;
            }));
        });
    }
    findTurn(gameId, turnId) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield exports.client.query('SELECT * FROM findTurn($1, $2)', [
                gameId,
                turnId
            ])).rows.find((row) => row);
        });
    }
    currentTurn(gameId) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield exports.client.query('SELECT * FROM currentTurn($1)', [gameId])).rows.find((row) => row);
        });
    }
    editTurn(gameId, turnId, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            const turn = yield this.findTurn(gameId, turnId);
            if (!turn) {
                throw new Error(`Turn not found for game with id ${turnId}`);
            }
            if (typeof callback === 'function') {
                const edited = yield callback(turn);
                return (yield exports.client.query(`UPDATE "turn" SET ${Object.keys(edited)
                    .filter(key => ['custom'].indexOf(key) !== -1)
                    .map(key => `"${key}" = ${formatValue(edited[key])}`)
                    .join(', ')} WHERE "gameId" = $1 and "turnId" = $2 RETURNING "turnId", "gameId", "index", "custom"`, [gameId, turnId])).rows.find((row) => row);
            }
            return turn;
        });
    }
    editCurrentTurn(gameId, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            const turn = yield this.currentTurn(gameId);
            if (!turn) {
                throw new Error(`Current turn not found for game with id ${gameId}`);
            }
            return yield this.editTurn(gameId, turn.turnId, callback);
        });
    }
    endCurrentTurn(gameId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.editCurrentTurn(gameId, (turn) => __awaiter(this, void 0, void 0, function* () {
                yield this.runEventListeners(types_1.DataStoreEvents.endCurrentTurn, turn, this);
                return turn;
            }));
            yield this.createTurn(gameId);
        });
    }
}
exports.PostgresDataStore = PostgresDataStore;
